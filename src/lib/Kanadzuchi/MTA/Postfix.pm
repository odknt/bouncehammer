# $Id: Postfix.pm,v 1.4 2010/10/25 20:09:25 ak Exp $
# Kanadzuchi::MTA::
                                               
 #####                  ##    ###  ##          
 ##  ##  ####   ##### ###### ##        ##  ##  
 ##  ## ##  ## ##       ##  ##### ###   ####   
 #####  ##  ##  ####    ##   ##    ##    ##    
 ##     ##  ##     ##   ##   ##    ##   ####   
 ##      ####  #####     ### ##   #### ##  ##  
package Kanadzuchi::MTA::Postfix;
use base 'Kanadzuchi::MTA';
use strict;
use warnings;

#  ____ ____ ____ ____ ____ ____ _________ ____ ____ ____ ____ 
# ||G |||l |||o |||b |||a |||l |||       |||v |||a |||r |||s ||
# ||__|||__|||__|||__|||__|||__|||_______|||__|||__|||__|||__||
# |/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|/__\|/__\|/__\|
#
# Postfix manual - bounce(5) - http://www.postfix.org/bounce.5.html
my $RxPostfix = [
	qr{\A\s+The Postfix program\z},
	qr{\A\s+The mail system\z},
	qr{\AThis is the Postfix program},
];

my $RxErrors = {
	'mailboxfull' => [
		# postfix/src/{local,virtula}/maildir.c:
		#  vstring_sprintf_prepend(why->reason, "maildir delivery failed: ");
		qr{maildir delivery failed: User disk quota ?.* exceeded},
		qr{maildir delivery failed: Domain disk quota ?.* exceeded},
		qr{mailbox exceeded the local limit},
	],
	'exceedlimit' => [
		qr{message too large},
	],
	'systemerror' => [
		qr{can[']t create user output file},
		qr{mail forwarding loop for },
		qr{mail for .+ loops back to myself},
		qr{mail system configuration error},
		qr{Server configuration error},
	],
	'mailererror' => [
		# postfix/src/global/pipe_command.c:
		#  vstring_prepend(why->reason, "Command failed: ", 
		qr{Command failed: },
	],
};

#  ____ ____ ____ ____ ____ _________ ____ ____ ____ ____ ____ ____ ____ 
# ||C |||l |||a |||s |||s |||       |||M |||e |||t |||h |||o |||d |||s ||
# ||__|||__|||__|||__|||__|||_______|||__|||__|||__|||__|||__|||__|||__||
# |/__\|/__\|/__\|/__\|/__\|/_______\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|
#
sub reperit
{
	# +-+-+-+-+-+-+-+
	# |r|e|p|e|r|i|t|
	# +-+-+-+-+-+-+-+
	#
	# @Description	Detect an error from Postfix
	# @Param <ref>	(Ref->Hash) Message header
	# @Param <ref>	(Ref->String) Message body
	# @Return	(String) Pseudo header content
	my $class = shift();
	my $mhead = shift() || return q();
	my $mbody = shift() || return q();

	#  ____           _    __ _      
	# |  _ \ ___  ___| |_ / _(_)_  __
	# | |_) / _ \/ __| __| |_| \ \/ /
	# |  __/ (_) \__ \ |_|  _| |>  < 
	# |_|   \___/|___/\__|_| |_/_/\_\
	#                                
	# Pre-Process eMail headers and body part of message which generated by Postfix
	#   e.g.) From: MAILER-DAEMON (Mail Delivery System)
	#         Subject: Undelivered Mail Returned to Sender
	return q() unless( $mhead->{'subject'} eq 'Undelivered Mail Returned to Sender' );
	return q() unless( $mhead->{'from'} =~ m{ [(]Mail Delivery System[)]\z} );

	my $xmode = { 'begin' => 1 << 0, 'error' => 1 << 1, 'endof' => 1 << 2 };
	my $xflag = 0;		# (Integer) Flag, 1 = is Posftix, 2 = <addr>...said:, 4 = Reporting MTA
	my $phead = q();	# (String) Pseudo email header
	my $pbody = q();	# (String) Pseudo body part
	my $xsmtp = q();	# (String) SMTP Command in transcript of session

	my $rhostsaid = q();	# (String) Remote host said: ...
	my $statintxt = q();	# (String) #n.n.n Status code in message body
	my $internalc = q();	# (String) Internal Error Code

	EACH_LINE: foreach my $el ( split( qq{\n}, $$mbody ) )
	{
		if( $xflag == 0 && grep { $el =~ $_ } @$RxPostfix )
		{
			# The mail system, The Postfix program, This is the Postfix program
			$xflag |= $xmode->{'begin'};
			next();
		}

		if( ( $xflag & $xmode->{'begin'} ) && ! ( $xflag & $xmode->{'endof'} ) )
		{
			# <recipient@example.com>: host mx.example.com [102.0.2.3] said:
			# <recipient@example.net> (expanded from <user@example.net>): host ...
			# $xflag |= 2 if( $el =~ m{\A[<].+[@].+[>][:]} || $el =~ m{\A[<].+[@].+[>] [(]expanded from} );
			#
			$xflag |= $xmode->{'error'} if( $el =~ m{\A[<].+[@].+[>][:]?} );
			$rhostsaid .= $el if( $xflag == 3 && $rhostsaid !~ m{ command[)]\z} );

			# Reporting-MTA: dns; mx.example.jp
			# X-Postfix-Queue-ID: FFFFFFFF0000
			# X-Postfix-Sender: rfc822; daemon@example.net
			# Arrival-Date: Wed, 29 Apr 2009 16:03:18 +0900
			#
			$xflag |= $xmode->{'endof'} if( $el =~ m{\A--\w.+/.+} # Boundary
					|| $el =~ m{\AContent-Type: message/} || $el =~ m{\AReporting-MTA: } );
			next();
		}

		if( ( $xflag & $xmode->{'error'} ) && length($xsmtp) == 0 )
		{
			#                   The mail system
			#
			# <recipient@example.com>: host mx.example.com [102.0.2.3] said:
			#    550 Unknown user recipient@example.com (in reply to end of DATA command)
			#
			$rhostsaid =~ y{ }{ }s;
			$rhostsaid =~ s{--\w.+\z}{};

			if( $rhostsaid =~ m{[ ]([45][.]\d+[.]\d+)[ ]} )
			{
				# D.S.N. in the error message
				$statintxt = 'Status: '.$1.qq(\n);
			}
			elsif( $rhostsaid =~ m{[ ]([45]\d{2})[ ]} )
			{
				# SMTP Status code -> D.S.N. ...
				$statintxt = 'Status: '.join('.',split(//,$1)).qq(\n);
			}

			foreach my $_er ( keys %$RxErrors )
			{
				last() unless $rhostsaid;

				if( grep { $rhostsaid =~ $_ } @{ $RxErrors->{$_er} } )
				{
					$internalc = Kanadzuchi::RFC3463->status($_er,'p','i');
					$statintxt = 'Status: '.$internalc.qq(\n);
					last();
				}
			}

			$xsmtp = $1 if( $rhostsaid =~ m{[(]in reply to .*([A-Z]{4}).*command[)]} );
		}

		if( $xflag & ( $xmode->{'begin'} + $xmode->{'error'} + $xmode->{'endof'} ) )
		{
			if( $el =~ m{\AStatus: } && length($statintxt) )
			{
				# Rewrite 'Status: x.y.z'
				$phead .= $statintxt.qq(\n);
			}
			else
			{
				$pbody .= $el.qq(\n)
			}
		}
	}

	$xsmtp ||= 'CONN';
	$phead .= $statintxt if( $phead eq q() && $statintxt );
	$phead .= 'X-Diagnosis: '.$rhostsaid.qq(\n);
	$phead .= __PACKAGE__->xsmtpcommand().$xsmtp.qq(\n) if( $phead );
	return $phead.$pbody;
}

1;
__END__
